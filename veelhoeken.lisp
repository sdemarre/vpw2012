(in-package :vpw2012)

(defclass simple-graph ()
  ((vertices :accessor vertices :initform (make-hash-table :test 'eq))
   (edges :accessor edges :initform (make-hash-table :test 'eq))))
(defmethod find-vertex ((graph simple-graph) x1 y1)
  (iter (for (key value) in-hashtable (vertices graph))
	(when (and (= x1 (caar value)) (= y1 (cdar value)))
	  (return key))))
(defmethod add-vertex ((graph simple-graph) x1 y1)
  (let ((v1 (gensym "vertex")))
    (setf (gethash v1 (vertices graph)) (cons (cons x1 y1) nil))
    v1))
(defmethod add-vertex-edge ((graph simple-graph) vertex-sym edge-sym)
  (push edge-sym (cdr (gethash vertex-sym (vertices graph)))))
(defmethod vertex-edges ((graph simple-graph) vertex-sym)
  (cdr (gethash vertex-sym (vertices graph))))
(defmethod add-edge ((graph simple-graph) x1 y1 x2 y2)
  (let ((v1 (find-vertex graph x1 y1))
	(v2 (find-vertex graph x2 y2)))
    (unless v1
      (setf v1 (add-vertex graph x1 y1)))
    (unless v2
      (setf v2 (add-vertex graph x2 y2)))
    (let ((edge-sym (gensym "edge")))
      (setf (gethash edge-sym (edges graph)) (cons v1 v2))
      (add-vertex-edge graph v1 edge-sym)
      (add-vertex-edge graph v2 edge-sym))))
(defmethod vertex-syms ((graph simple-graph))
  (iter (for (key value) in-hashtable (vertices graph))
	(collect key)))
(defmethod edge-list ((graph simple-graph) vertex-sym)
  (rest (gethash vertex-sym (vertices graph))))
(defmethod get-vertex-coords ((graph simple-graph) v)
  (first (gethash v (vertices graph))))
(defmethod has-horizontal-edge-between-p ((graph simple-graph) v1 v2)
  (= (cdr (get-vertex-coords graph v1))
     (cdr (get-vertex-coords graph v2))))
(defmethod has-vertical-edge-between-p ((graph simple-graph) v1 v2)
  (= (car (get-vertex-coords graph v1))
     (car (get-vertex-coords graph v2))))
(defmethod is-rectangle-p ((graph simple-graph) v1 v2 v3 v4)
					;(print-coords graph (list v1 v2 v3 v4))
  (let* ((vertices (sort (copy-list (list v1 v2 v3 v4))
			      #'(lambda (v1 v2) (or (< (cdr v1) (cdr v2))
						    (and (= (cdr v1) (cdr v2))
							 (< (car v1) (car v2))))) 
			      :key #'(lambda (vertex) (get-vertex-coords graph vertex)))))
    (destructuring-bind (v1 v2 v3 v4) vertices
					;(print-coords graph (list v1 v2 v3 v4))
      (and (has-horizontal-edge-between-p graph v1 v2)
	   (has-horizontal-edge-between-p graph v3 v4)
	   (has-vertical-edge-between-p graph v1 v3)
	   (has-vertical-edge-between-p graph v2 v4)))))
(defun print-coords (graph vertex-syms)
  (format t "~{~a~^,~}~%" (mapcar #'(lambda (v) (get-vertex-coords graph v)) vertex-syms)))
(defmethod count-rectangles ((graph simple-graph))
  (let ((candidate-vertices (remove-if-not #'(lambda (vertex) (rest (edge-list graph vertex))) (vertex-syms graph))))
    (iter top (for v1 on candidate-vertices)
	  (iter (for v2 on (rest v1))
		(iter (for v3 on (rest v2))
		      (iter (for v4 on (rest v3))
			    (in top (when (is-rectangle-p graph (car v1) (car v2) (car v3) (car v4))
				      (counting t)
				      (print-coords graph (list (car v1) (car v2) (car v3) (car v4)))))))))))

(defun solve-veelhoeken-problem (line-producer)
  (let ((number-edges (parse-integer (funcall line-producer)))
	(graph (make-instance 'simple-graph)))
    (iter (for edge-idx from 1 to number-edges)
	  (destructuring-bind (x1 y1 x2 y2)
	      (mapcar #'(lambda (n) (parse-integer n :junk-allowed t))
		      (split-sequence:split-sequence #\Space (funcall line-producer)))
	    (add-edge graph x1 y1 x2 y2)))
    (count-rectangles graph)))
(defun solve-veelhoeken-problems ()
  (with-example-entries ("veelhoeken" line-producer)
    (format t "~a~%" (solve-veelhoeken-problem line-producer))))
