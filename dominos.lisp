(in-package :vpw2012)

(defconstant +max-eyes+ 6)
(defconstant +num-rows+ 7)
(defconstant +num-columns+ 8)


(defun read-box-definition (line-producer)
  (let ((box (make-array (list +num-rows+ +num-columns+))))
    (iter (for row from 0 to (1- +num-rows+))
	  (let ((line (funcall line-producer)))
	    (iter (for element in (split-sequence:split-sequence #\Space line))
		  (for column from 0 to (1- +num-columns+))
		  (setf (aref box row column) (cons (parse-integer element) nil)))))
    box))
(defun cell-used-p (box row column)
  (cdr (aref box row column)))
(defun cell-value (box row column)
  (car (aref box row column)))
(defun set-cell-value (box row column value)
  (setf (car (aref box row column)) value))
(defsetf cell-value set-cell-value)
(defun use-cell (box row column)
  (setf (cdr (aref box row column)) t))
(defun dont-use-cell (box row column)
  (setf (cdr (aref box row column)) nil))

(defclass domino-solver (rbt-solver)
  ((remaining-dominos :accessor remaining-dominos :initarg :remaining-dominos)
   (box :accessor box :initarg :box)
   (total-solutions :accessor total-solutions :initform 0)
   (solution :accessor solution :initform nil)
   (solutions :accessor solutions :initform nil)))

(defmethod is-solution-p ((solver domino-solver))
  (null (remaining-dominos solver)))

(defmethod handle-solution ((solver domino-solver))
  (push (solution solver) (solutions solver))
  (incf (total-solutions solver)))

(defun is-up-p (o) (declare (inline is-up-p)) (or (eq :up o)))
(defun is-down-p (o) (declare (inline is-down-p)) (or (eq :down o)))
(defun is-left-p (o) (declare (inline is-left-p)) (or (eq :left o)))
(defun is-right-p (o) (declare (inline is-right-p)) (or (eq :right o)))
(defun possible-orientations-at-position (row column)
  (let ((orientations (list :up :down :left :right)))
    (when (= row 0)
      (setf orientations (remove-if 'is-up-p orientations)))
    (when (= row (1- +num-rows+))
      (setf orientations (remove-if 'is-down-p orientations)))
    (when (= column 0)
      (setf orientations (remove-if 'is-left-p orientations)))
    (when (= column (1- +num-columns+))
      (setf orientations (remove-if 'is-right-p orientations)))
    orientations))
(defun compute-possible-other-coords ()
  (let ((other-coords-box (make-array (list +num-rows+ +num-columns+))))
    (iter (for row from 0 to (1- +num-rows+))
	  (iter (for column from 0 to (1- +num-columns+))
		(let* ((orientations (possible-orientations-at-position row column))
		       (sym-orientations (remove-if #'(lambda (o) (or (is-up-p o) (is-left-p o))) orientations)))
		  (setf (aref other-coords-box row column) 
			(cons (mapcar #'(lambda (orientation) (other-coord row column orientation)) orientations)
			      (mapcar #'(lambda (orientation) (other-coord row column orientation)) sym-orientations))))))
    other-coords-box))
(defun other-coord (row column orientation)
  (cond ((is-up-p orientation) (cons (1- row) column))
	((is-down-p orientation) (cons (1+ row) column))
	((is-left-p orientation) (cons row (1- column)))
	((is-right-p orientation) (cons row (1+ column)))))
(defparameter +possible-other-coords+ (compute-possible-other-coords))
(defun possible-other-coords (row column domino)
  (let+ (((a . b) domino))
    (if (= a b)
	(cdr (aref +possible-other-coords+ row column))
	(car (aref +possible-other-coords+ row column)))))
(defstruct extension
  domino position other-coords)
(defun cell-values-match (box row column row-2 column-2 domino)
  (let+ (((a . b) domino))
    (and (= (cell-value box row column) a)
	 (= (cell-value box row-2 column-2) b))))
(defmethod possible-extensions ((solver domino-solver))
  "returns a list of extensions that can be used by extend-solution and restore-solution"  
  (let ((domino (car (remaining-dominos solver))))
    (iter outer (for row from 0 to (1- +num-rows+))
	  (iter (for column from 0 to (1- +num-columns+))
		(when (not (cell-used-p (box solver) row column))
		  (iter (for other-coords in (possible-other-coords row column domino))
			(let+ (((row-2 . column-2) other-coords))
			  (when (and (not (cell-used-p (box solver) row-2 column-2)) 
				     (cell-values-match (box solver) row column row-2 column-2 domino))
			    (in outer (collect (make-extension :domino domino
							       :position (cons row column)
							       :other-coords other-coords)))))))))))

(defmethod extend-solution ((solver domino-solver) extension)
  (push extension (solution solver))
  (let+ (((row . column) (extension-position extension))
	 ((row-2 . column-2) (extension-other-coords extension))
	 (box (box solver)))
    (pop (remaining-dominos solver))
    (use-cell box row column)
    (use-cell box row-2 column-2)))

(defmethod restore-solution ((solver domino-solver) extension)
  (pop (solution solver))
  (let+ ((domino (extension-domino extension))
	 ((row . column) (extension-position extension))
	 ((row-2 . column-2) (extension-other-coords extension))
	 (box (box solver)))
    (push domino (remaining-dominos solver))
    (dont-use-cell box row column)
    (dont-use-cell box row-2 column-2)))

(defun print-box (box)
  (with-output-to-string (s)
    (format s "~%")
    (iter (for row from 0 to (1- +num-rows+))
	  (iter (for column from 0 to (1- +num-columns+))
		(format s "~a~a" (if (cell-used-p box row column) "." " ") (cell-value box row column)))
	  (format s "~%"))))
(defmethod print-object ((solver domino-solver) stream)
  (print-unreadable-object (solver stream :type t)
    (format stream "~a" (print-box (box solver)))
    (format stream "~a~%" (remaining-dominos solver))
    (format stream "~a~%" (solution solver))))

(defun possible-domino-stones ()
  (iter outer (for a from 0 to +max-eyes+)
	(iter (for b from a to +max-eyes+)
	      (in outer (collect (cons a b))))))
(defun solve-domino-problem (line-producer)
  (let+ ((box (read-box-definition line-producer))
	 (solver (make-instance 'domino-solver :box box :remaining-dominos (possible-domino-stones))))
    (solve-rbt solver)
    solver))
(defun solve-domino-problems ()
  (let* ((domino-lines (contest-input-lines "dominos"))
	 (line-producer (make-line-producer domino-lines))
	 (number-problems (parse-integer (funcall line-producer) :junk-allowed t)))
    (iter (for domino-problem-index from 1 to number-problems)
	  (let ((solver (solve-domino-problem line-producer)))
	    (format t "~a~%" (total-solutions solver)))
	  ;; consume empty line
	  (funcall line-producer))))
