(in-package :vpw2012)

(defconstant +max-eyes+ 6)
(defconstant +num-rows+ 8)
(defconstant +num-columns+ 7)


(defun read-box-definition (line-producer)
  (let ((box (make-array (list +num-rows+ +num-columns+))))
    (iter (for row from 1 to +num-rows+)
	  (let ((line (funcall line-producer)))
	    (iter (for element in (split-sequence:split-sequence #\Space line))
		  (for column from 1 to +num-columns+)
		  (setf (aref box (1- row) (1- column)) (cons (parse-integer element) nil)))))
    box))
(defun cell-used-p (box row column)
  (cdr (aref box (1- row) (1- column))))
(defun cell-value (box row column)
  (car (aref box (1- row) (1- column))))
(defun set-cell-value (box row column value)
  (setf (car (aref box (1- row) (1- column))) value))
(defsetf cell-value set-cell-value)
(defun use-cell (box row column)
  (setf (cdr (aref box (1- row) (1- column))) t))
(defun dont-use-cell (box row column)
  (setf (cdr (aref box (1- row) (1- column))) nil))

(defclass domino-solver (rbt-solver)
  ((row :accessor row :initarg :row)
   (column :accessor column :initarg :column)
   (remaining-dominos :accessor remaining-dominos :initarg :remaining-dominos)
   (box :accessor box :initarg :box)
   (total-solutions :accessor total-solutions :initform 0)))

(defmethod is-solution-p ((solver domino-solver))
  (null (remaining-dominos solver)))

(defmethod handle-solution ((solver domino-solver))
  (incf (total-solutions solver)))

(defun next-pos (current-row current-column)
  "returns the next position in the box (left to right, top to bottom) or nil if at end."
  (if (= current-column +num-columns+)
      (if (< current-row +num-rows+)
	  (cons (1+ current-row) 1))
      (cons current-row (1+ current-column))))
(defun compute-possible-orientations-box ()
  (let ((result (make-array (list +num-rows+ +num-columns+))))
    (iter (for row from 1 to +num-rows+)
	  (iter (for column from 1 to +num-columns+)
		(setf (aref result (1- row) (1- column))
		      (cond ((and (> row 1) (< row +num-rows+)
				  (> column 1) (< column +num-columns+))
			     (cons
			      (list :up :down :left :right)
			      (list :up :r-up :down :r-down :left :r-left :right :r-right)))
			    ((and (= column 1) (= row 1))
			     (cons
			      (list :down :right)
			      (list :down :r-down :right :r-right)))
			    ((and (= column 1) (= row +num-rows+))
			     (cons
			      (list :up :right)
			      (list :up :r-up :right :r-right)))
			    ((and (= column +num-columns+) (= row 1))
			     (cons
			      (list :down :left)
			      (list :down :r-down :left :r-left)))
			    ((and (= column +num-columns+) (= row +num-rows+))
			     (cons
			      (list :up :left)
			      (list :up :r-up :left :r-left)))
			    ((= column 1)
			     (cons
			      (list :up :down :right)
			      (list :up :r-up :down :r-down :right :r-right)))
			    ((= column +num-columns+)
			     (cons
			      (list :up :down :left)
			      (list :up :r-up :down :r-down :left :r-left)))
			    ((= row 1)
			     (cons
			      (list :down :left :right)
			      (list :down :r-down :left :r-left  :right :r-right)))
			    ((= row +num-rows+)
			     (cons
			      (list :up :left :right)
			      (list :up :r-up :left :r-left :right :r-right)))))))
    result))
(defconstant +orienation-box+ (compute-possible-orientations-box))
(defun possible-orientations (domino row column)
  ":up :r-up :down :r-down :left :r-left :right :r-right, but beware borders.
also, if domino is a double, don't add the r-xxx versions, as they are the same"
  (let+ (((a . b) domino))
    (if (= a b)
	(car (aref +orientation-box+ row column))
	(cdr (aref +orientation-box+ row column)))))
(defun other-coord-for-domino (row column orientation)
  (cond ((or (eq orientation :up) (eq orientation :r-up)) (cons (1- row) column))
	((or (eq orientation :down) (eq orientation :r-down)) (cons (1+ row) column))
	((or (eq orientation :left) (eq orientation :r-left)) (cons row (1- column)))
	((or (eq orientation :right) (eq orientation :r-right)) (cons row (1+ column)))))
(defmethod possible-extensions ((solver domino-solver))
  )

(defun possible-domino-stones ()
  (iter outer (for a from 0 to +max-eyes+)
	(iter (for b from a to +max-eyes+)
	      (in outer (collect (cons a b))))))
(defun solve-domino-problem (line-producer)
  (let ((box (read-box-definition line-producer)))    
    (iter (for row from 0 to (1- +num-rows+))
	  (iter (for column from 0 to (1- +num-columns+))))))
(defun solve-domino-problems (domino-lines)
  (let ((line-producer (make-line-producer domino-lines)))
    (let ((number-problems (parse-integer (funcall line-producer) :junk-allowed t)))
      (iter (for domino-problem-index from 1 to number-problems)
	    (solve-domino-problem line-producer)
	    ;; consume empty line
	    (funcall line-producer)))))
