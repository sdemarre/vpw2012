(in-package :vpw2012)

(defconstant +max-eyes+ 6)
(defconstant +num-rows+ 8)
(defconstant +num-columns+ 7)


(defun read-box-definition (line-producer)
  (let ((box (make-array (list +num-rows+ +num-columns+))))
    (iter (for row from 1 to +num-rows+)
	  (let ((line (funcall line-producer)))
	    (iter (for element in (split-sequence:split-sequence #\Space line))
		  (for column from 1 to +num-columns+)
		  (setf (aref box (1- row) (1- column)) (cons (parse-integer element) nil)))))
    box))
(defun cell-used-p (box row column)
  (cdr (aref box (1- row) (1- column))))
(defun cell-value (box row column)
  (car (aref box (1- row) (1- column))))
(defun set-cell-value (box row column value)
  (setf (car (aref box (1- row) (1- column))) value))
(defsetf cell-value set-cell-value)
(defun use-cell (box row column)
  (setf (cdr (aref box (1- row) (1- column))) t))
(defun dont-use-cell (box row column)
  (setf (cdr (aref box (1- row) (1- column))) nil))

(defclass domino-solver (rbt-solver)
  ((row :accessor row :initarg :row)
   (column :accessor column :initarg :column)
   (remaining-dominos :accessor remaining-dominos :initarg :remaining-dominos)
   (box :accessor box :initarg :box)
   (total-solutions :accessor total-solutions :initform 0)))

(defmethod is-solution-p ((solver domino-solver))
  (null (remaining-dominos solver)))

(defmethod handle-solution ((solver domino-solver))
  (incf (total-solutions solver)))

(defun next-pos (current-row current-column)
  "returns the next position in the box (left to right, top to bottom) or nil if at end."
  (if (= current-column +num-columns+)
      (if (< current-row +num-rows+)
	  (cons (1+ current-row) 1))
      (cons current-row (1+ current-column))))
(defun possible-orientations (domino box row column))
(defmethod possible-extensions (solver domino-solver)
  )

(defun possible-domino-stones ()
  (iter outer (for a from 0 to +max-eyes+)
	(iter (for b from a to +max-eyes+)
	      (in outer (collect (cons a b))))))
(defun solve-domino-problem (line-producer)
  (let ((box (read-box-definition line-producer)))
    (iter (for row from 0 to (1- +num-rows+))
	  (iter (for column from 0 to (1- +num-columns+))))))
(defun solve-domino-problems (domino-lines)
  (let ((line-producer (make-line-producer domino-lines)))
    (let ((number-problems (parse-integer (funcall line-producer) :junk-allowed t)))
      (iter (for domino-problem-index from 1 to number-problems)
	    (solve-domino-problem line-producer)
	    ;; consume empty line
	    (funcall line-producer)))))
